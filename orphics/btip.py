from __future__ import print_function
import numpy as np
from orphics import maps,io,stats
from enlib import enmap,resample,bench

def dpower(shape,wcs,theory,ls,lbeams,n2d,tshape,twcs,pol=False):

    tmodlmap = enmap.modlmap(tshape,twcs)
    cmb2d = theory.lCl('TT',tmodlmap)*maps.interp(ls,lbeams)(tmodlmap)**2.

    nshift = np.fft.fftshift(n2d)
    
    nlow = enmap.downgrade(nshift, ndown)


def mask_map(imap,iys,ixs,hole_arc,hole_frac=0.6):
    shape,wcs = imap.shape,imap.wcs
    Ny,Nx = shape[-2:]
    px = maps.resolution(shape,wcs)*60.*180./np.pi
    hole_n = int(round(hole_arc/px))
    hole_ny = hole_nx = hole_n
    oshape,owcs = enmap.geometry(pos=(0.,0.),shape=(2*hole_n,2*hole_n),res=px*np.pi/180./60.)
    modrmap = enmap.modrmap(oshape,owcs)
    mask = enmap.ones(shape,wcs)
    
    for iy,ix in zip(iys,ixs):
        if iy<=hole_n or ix<=hole_n or iy>=(Ny-hole_n) or ix>=(Nx-hole_n): continue
        vslice = imap[np.int(iy-hole_ny):np.int(iy+hole_ny),np.int(ix-hole_nx):np.int(ix+hole_nx)]
        if np.any(vslice.shape!=oshape): continue
        vslice[modrmap<(hole_frac*hole_arc)*np.pi/180./60.] = np.nan # !!!! could cause a bias
        mask[np.int(iy-hole_ny):np.int(iy+hole_ny),np.int(ix-hole_nx):np.int(ix+hole_nx)][modrmap<hole_arc*np.pi/180./60.] = 0
        
    return mask



def inpaint_map(imap,ras,decs,radii_tags,radii_dict,tot_power_2d,seed=None):
    """
    Brute-force inpaints a map in circular regions.

    imap -- (Ny,Nx) enmap
    ras  -- list of RA of centers in degrees, length M
    decs -- list of DEC of centers in degrees, length M
    radii -- list of strings specifying radius tag for each object, length M
    radii_dict -- dict mapping radius tag string to float value of radius in arcminutes, length K
                  Most expensive operation scales with K.
    tot_power_2d -- total power in map in physical units (e.g. uK^2 radians)

    """


    class G:
        pass

    geometries = {}
    tags = radii_dict.keys()
    for key in tags:
        geometries[key] = calculate_circular_geometry(shape,wcs)




def prepare_circular_mask(stamp,hole_arcminutes):
    '''This routine accepts a stamp as a 2D array. The region
    within hole_arcminutes is masked, and the mean of the region outside it
    is subtracted from the stamp. It returns the masked stamp and the value
    of the mean of the unmasked region that needs to be added back after
    inpainting.

    '''

    stamp[stamp.modrmap()<hole_arcminutes*np.pi/180./60.] = np.nan
    unmasked_mean = np.nanmean(stamp)
    stamp -= unmasked_mean

    return stamp, unmasked_mean


def get_geometry_shapes(shape,wcs,hole_arcminutes):
    modrmap = enmap.modrmap(shape,wcs)
    m1 = np.where(modrmap.reshape(-1)<hole_arcminutes*np.pi/180./60.)[0]
    m2 = np.where(modrmap.reshape(-1)>=hole_arcminutes*np.pi/180./60.)[0]
    return m1.size,m2.size


def make_circular_geometry(shape,wcs,context_arcmin,hole_arcmin,power2d,buffer_factor = 2,verbose=False):
    '''Makes the circular geometry matrices that need to be pre-calculated for later inpainting.

    Arguments
    ---------

    input2DPower - ndarray containing 2D power spectrum of a map. It need not already have been
                   downsampled to the shape of the stamp cutout
    inputLy
    inputLx      - the fourier wavenumbers corresponding to the y and x axes of the stamp cutout
    stampArc     - the width in arcminutes of the stamp cut out
    stampPxX      - the pixel width in arcminutes of the stamp cut out in the x direction
    stampPxY      - the pixel width in arcminutes of the stamp cut out in the y direction
    holeArc      - the radius of the circular hole in arcminutes
    bufferFactor - the pixel covariance matrix will be calculated on a periodic stamp larger by this
                   factor
    verbose      - True if you want more commentary

    Returns
    -------

    meanMul      - a matrix that has shape (nh,nc) where nh is the number of pixels in the hole and
                   nc is the number of pixels outside (in the "context"). It should be multiplied
                   by a vector (nc) containing pixels outside to get a vector (nh) for the mean
                   value of the pixels inside
    covRoot      - a (nh,nh) sqrt(covariance matrix) that can be used to generate a random realization
                   in the hole. This can be generated by multiplying the sqrt of cov by a vector (nh)
                   of standard normal variables. The generated vector should be added to the mean value
                   obtained using meanMul
    pcov         - the pixel-pixel covariance matrix used in intermediate steps, if you want to re-use it
    targetTemplate - a liteMap template of the stamp cutout
    m1           - a boolean array that can be used to select the hole region
    m2           - a boolean array that can be used to select the context region


    '''

    arc = context_arcmin
    res = maps.resolution(shape,wcs)*60.*180./np.pi
                                                      
    bshape,bwcs = maps.rect_geometry(width_arcmin=arc*buffer_factor,px_res_arcmin=res)
    tshape,twcs = maps.rect_geometry(width_arcmin=arc,px_res_arcmin=res)
    sny,snx = tshape
    bmodlmap = enmap.modlmap(bshape,bwcs)
    modlmap = enmap.modlmap(shape,wcs)

    if verbose: print ("Downsampling power...")
    Niy,Nix = shape[-2:]
    Noy,Nox = bshape[-2:]
    
    # print(bshape,tshape,power2d.shape)
    # io.plot_img(np.fft.fftshift(np.log10(power2d)))
    #out_power = resample.resample_fft(power2d,bshape[-2:],axes=[-2,-1])
    #out_power = np.fft.ifftshift(resample.resample_fft(np.fft.fftshift(power2d),bshape[-2:],axes=[-2,-1]))
    
    out_power = resample.resample_bin(power2d,factors=[float(Noy)/Niy,float(Nox)/Nix],axes=[-2,-1]) ## UNCOMMENT

    # TESTING
    """
    Lessons:
    1. resample_bin is not downsampling correctly
    2. tests continue with p2d made from scratch theory on small stamp geometry
    3. band limited power spectrum introduces large errors (probably because cinv is not stable)
    4. can fill p2d with noise, but what if map being inpainted is band limited? get speckles in holes from small scales
    """
    # from orphics import cosmology
    # cc = cosmology.Cosmology(lmax=3000,pickling=True,dimensionless=False)
    # out_power = cc.theory.lCl('TT',bmodlmap)*maps.gauss_beam(bmodlmap,5.0)**2.+(60.*np.pi/180./60.)**2.
    

    io.plot_img(np.fft.fftshift(np.log10(power2d)),io.dout_dir+"upower.png")
    io.plot_img(np.fft.fftshift(np.log10(out_power)),io.dout_dir+"dpower.png")

    
    if verbose: print ("Starting slow part...")
    d = maps.diagonal_cov(out_power)
    with bench.show("pixcov"):
        pcov = maps.pixcov(bshape,bwcs,d)[0,0,:sny,:snx,:sny,:snx]
    modrmap = enmap.modrmap(tshape,twcs)
    m1 = np.where(modrmap.reshape(-1)<hole_arcmin*np.pi/180./60.)[0]
    m2 = np.where(modrmap.reshape(-1)>=hole_arcmin*np.pi/180./60.)[0]

    with bench.show("geom"):
        meanMul, cov = get_geometry(pcov.reshape(sny*snx,sny*snx),m1,m2)
    
    covRoot = stats.eig_pow(cov,0.5)

    return meanMul, covRoot, pcov, tshape,twcs, m1, m2


def get_geometry(pixcov,m1,m2):
    # m1 is hole
    # m2 is context

    Cinv = np.linalg.inv(pixcov)
    # Apply woodbury! to ones everywhere mean or better yet horizontal stripes for each row of the stamp. Correlation length along x can be completely large. Subtracting mean of unmasked region unnecessary.
    cslice = Cinv[m1][:,m1]
    meanMul1 = np.linalg.inv(cslice)

    mul2 = Cinv[m1][:,m2]
    meanMul = np.dot(-meanMul1,mul2)
    cov = np.linalg.pinv(Cinv[m1][:,m1])
    return meanMul, cov


def fill_hole(masked_stamp,meanMatrix,holeArc,m1,m2,covRoot=None):
    '''Returns the result of an inpaint operation as a 1d unraveled vector

    Arguments
    ---------

    masked_liteMap_stamp - the cutout stamp that contains a masked hole and
                           unmasked context
    meanMatrix           - an (nh,nc) matrix. See docs for make_circular_geometry
    holeArc              - radius of masked hole in arcminutes
    m1                   - a 1d boolean selecting the hole region on an unraveled stamp
    m2                   - a 1d boolean selecting the context region on an unraveled stamp
    covRoot              - the square root of the covariance matrix inside the hole. See
                           docs for make_circular_geometry. If unspecified, the random
                           realization returned is zero.

    Returns
    -------

    mean  -  a 1d (nh) vector containing the mean inpainted value constrained according
             to the context
    rand  -  a 1d (nh) vector containing a random realization inside the hole
    sim   -  a 1d (nh) vector containing the sum of mean and rand

    '''

    mean = np.dot(meanMatrix,masked_stamp.reshape(-1)[m2])
    r = np.random.normal(0.,1.,size=(m1.size))
    if covRoot is not None:
        rand = np.dot(covRoot,r)
    else:
        rand = 0.
    sim = mean + rand
    return mean, rand, sim

                                                      



def fill_map(imap,iys,ixs,hole_arc,mean_mul,cov_root,m1,tshape,twcs,seed=None):
    Ny,Nx = imap.shape[-2:]
    sny,snx = tshape[-2:]
    modrmap = enmap.modrmap(tshape,twcs)
    ttemplate = enmap.empty(tshape,twcs)

    iys = iys.astype(np.int)
    ixs = ixs.astype(np.int)

    m1 = np.where(modrmap.reshape(-1)<hole_arc*np.pi/180./60.)[0]
    m2 = np.where(modrmap.reshape(-1)>=hole_arc*np.pi/180./60.)[0]    
    if seed is not None: np.random.seed(seed)

    # Further improvement possible by pre-calculating random vectors
    
    outside = 0
    j = 0
    for i,(iy,ix) in enumerate(zip(iys,ixs)):

        sy = iy-sny/2
        ey = iy+sny/2
        sx = ix-snx/2
        ex = ix+snx/2
        oslice = imap[sy:ey,sx:ex]

        if np.any(oslice.shape!=tshape) or sy<0 or sx<0 or ey>=Ny or ex>=Nx:
            outside+=1
            continue

        j += 1
        ttemplate = oslice.copy()
        if j==1: io.plot_img(ttemplate,io.dout_dir+"ttemplate.png")
        
        masked, maskedMean = prepare_circular_mask(ttemplate,hole_arc)
        if j==1: io.plot_img(masked,io.dout_dir+"masked.png")
                
        masked = np.nan_to_num(masked)
        mean, rand, sim = fill_hole(masked,mean_mul,hole_arc,m1,m2,cov_root)


        a = masked.reshape(-1)
        # a[m1] = sim+maskedMean
        a[m1] = mean+maskedMean
        a[m2] = oslice.reshape(-1)[m2]
        oslice[:,:] = a.reshape(masked.shape)

        
        
    if outside>0: print (outside, " pt source(s) at edge.")





    
def paste(targetTemplate,m,pasteThis):
    '''Paste the result of an inpaint operation into a rectangular
    np array in a liteMap

    targetTemplate  - a liteMap with the shape of your cutout stamp
    m               - a 1d boolean array that specifies where in the unraveled
                      cutout stamp the hole is
    pasteThis - the result of an inpaint operation, say from fill_hole
    '''
    a = targetTemplate.copy()
    a.reshape(-1)[m] = pasteThis
    a.reshape(targetTemplate.shape)
    return a
